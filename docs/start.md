# 快速开始

## 构建

- 依赖：
  - cmake
  - g++
  - nlohmann-json
  - lua
  - sol2
  - boost


执行 `./build.sh` 可在 `build` 目录下构建基础的工作文件夹。


## 运行依赖

- Lua
- curl
- gcc-libs
- lagrange 等支持正向 WebSocket 的 OneBot 实现
- ...

## 使用

### 1. 配置

```json
{
  "port": "5705",
  "self_id": "123456789",
  "private_black": true,
  "private_list": [],
  "admin_list": {
    "65432123": 100
  },
  "black_list": [
    "87654321",
    "987654321"
  ],
  "lua_state_list": [
    {
      "name": "chat",
      "path": "user_luarc/chat"
    }
  ],
  "group_list": [],
  "Custom_Config": {
    "Test_Flag": "123456789"
  }
}
```
1. 将 `Self_ID` 字段的值改为 bot qq 号
2. 在 `group_list` 中添加你想启用 bot 功能的群聊
3. 将 `admin_list` 中 100 前的数字改为 bot 主人的 QQ 号
4. 更多字段见配置页。

### 2. 向 `Answer` 文件夹内添加内容

这里应当是若干个标准的 json 文件。每个 json 文件的数据结构应当包含一个键为 Answer，值为符合应答组结构的数组。即：
```json
{
    "Answer":[应答组0, 应答组1, ...]
}
```
所有在这个文件夹中的 Answer 数组最后将会在运行时被合并到一起。

> 25.200: 也可以是一个 Lua 文件，
> 只需返回一个格式与上述 json 一致的 Lua 表。


### 3. 应答组

详见应答组的页面。

简单讲，有这样几个字段：
一个应答组至少要包含三个字段：`regex` `anss` `pri`。
程序的逻辑是：
1. 将所有的应答组依照其 `pri` 值，从大到小排序。
2. 收到消息后，依照顺序根据 `regex` (和消息属性)检查是否符合要求
3. 若符合要求，依照 `anss` 来产生操作。

#### regex

`regex` 用于描述匹配要求。从实例来解释：

1. 要求当消息中出现 `早` 时判定为符合要求：
   > `"regex": "早"`
1. 要求当消息中需同时出现 `早` `好` 时判定为符合要求：
   > `"regex": {"and":["早","好"]}`
2. 要求当消息中出现 `早` 或 `好` 时即判定为符合要求：
   > `"regex": ["早","好"]`
3. 要求当消息中不出现 `早` 或 `好` 时即判定为符合要求：
   > `"regex": {"not":["早","好"]}`


4. 要求当消息中需要 <同时出现 `早`  `好` 时> 或 <出现 `你好` 时> 即判定为符合要求：
   > `"regex": [{"and":["早","好"]},"你好"]`
5. 要求当消息中出现 `早` 或 `好` 时，同时不出现`晚`或`午`即判定为符合要求：
   > `"regex": {"and":[["早","好"],{"not":["晚","午"]}]}`

以上所有的字符串值都是以正则表达式进行判断。

#### anss

`anss` 用于描述应答操作。从实例来解释：

1. 只执行输出 `你好`：
   > `"anss": ["你好"]`
1. 执行输出 `你好` 或 `你不好`：
   > `"anss": ["你好","你不好"]`
1. 执行输出 `你好` 或 `你不好`, 概率为 5:1 ：
   > `"anss": [{"text":"你好","weight":5},"你不好"]`
2. 执行输出 `A` `B` `C` 与 `1` `2` 的任意组合：
   > `"anss": {"and":[["A","B","C"],["1","2"]]}`


